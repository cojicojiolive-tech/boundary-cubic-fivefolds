# -*- coding: utf-8 -*-


# This file was *autogenerated* from the file adjacency.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7 = Integer(7); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)# adjacency.sage
#
# Title:
#   1-PS weight from exponent-face computation (cubic fivefolds, Section 6)
#
# Purpose:
#   Reconstruct a one-parameter subgroup (1‑PS) weight vector r ∈ Z^7 (sum r_i = 0)
#   as the primitive integer normal to the affine span of:
#      { the barycenter η = (1,1,1,1,1,1,1)  and  five degree-3 exponent vectors }.
#   This is the micro-step behind the face enumeration used in the adjacency / wall
#   crossing analysis in Section 6 (Kirwan's stratification).
#
# Context in the paper:
#   - The list of candidate weight vectors (r1, ..., r22) appears in Proposition 2.3.
#   - The six exponent vectors below are exactly those of the six monomials used in
#     the convex-hull identity (1) in Section 4.1 (Case k = 1).
#   - With any five of the six exponent vectors, the affine span together with η
#     determines a unique (up to scaling/sign) normal r. We print it in the paper’s
#     convention.
#
# Output convention (to match the paper / Mathematica notebook):
#   - From the right kernel we get a rational vector (defined up to scalar).
#   - We clear denominators, divide by gcd, and fix the sign by making the first
#     nonzero entry positive (canonicalization).
#   - Finally, *for printing*, we multiply by -1 and sort in decreasing order so the
#     printed list matches the paper’s representative (e.g. [[6, 4, 2, 1, -2, -3, -8]]).
#
# How to run:
#   sage adjacency.sage
#
# Expected output for the exponent set below:
#   [[6, 4, 2, 1, -2, -3, -8]]
#
# Requirements:
#   - SageMath (tested on recent 9.x/10.x)
#   - No external dependencies

from itertools import combinations

# ===== Parameters =====
dim = _sage_const_7    # ambient dimension: variables x0,...,x6
deg = _sage_const_3    # total degree of the monomials (cubic); unused but kept for clarity

# ===== Exponent set (Section 4.1, equation (1)) =====
# These are the exponent vectors of the six monomials used in the convex-hull identity:
#   x2*x3^2,  x1*x3*x4,  x2^2*x5,  x0*x5^2,  x1^2*x6,  x0*x4*x6
# Each vector lists exponents of (x0, x1, x2, x3, x4, x5, x6).
indexset = [
    vector(ZZ, [_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]),  # x2 * x3^2
    vector(ZZ, [_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ]),  # x1 * x3 * x4
    vector(ZZ, [_sage_const_0 ,_sage_const_0 ,_sage_const_2 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ]),  # x2^2 * x5
    vector(ZZ, [_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_2 ,_sage_const_0 ]),  # x0 * x5^2
    vector(ZZ, [_sage_const_0 ,_sage_const_2 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]),  # x1^2 * x6
    vector(ZZ, [_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_1 ]),  # x0 * x4 * x6
]

# ===== Utilities =====
def primitive_integer_vector(v):
    """
    Convert a rational vector v ∈ QQ^n to a primitive integer vector in ZZ^n:
      (i) clear denominators by multiplying by lcm of denominators and taking numerators;
     (ii) divide by gcd of nonzero entries;
    (iii) fix the sign so the first nonzero entry is positive.

    Returns: vector(ZZ, n)
    """
    vv = vector(QQ, v)
    if vv.is_zero():
        return vector(ZZ, [_sage_const_0 ]*vv.length())

    den_lcm = lcm([x.denominator() for x in vv])
    w = vector(ZZ, [(x * den_lcm).numerator() for x in vv])

    g = gcd([abs(a) for a in w if a != _sage_const_0 ])
    if g != _sage_const_0 :
        w = vector(ZZ, [a // g for a in w])

    # Sign convention: make first nonzero entry positive
    for a in w:
        if a != _sage_const_0 :
            if a < _sage_const_0 :
                w = -w
            break
    return w

def fingerprint_from_nullspace(M):
    """
    Compute a 1-dimensional right kernel of M over QQ, turn a basis vector into
    a primitive integer vector, then *forget positions* and sort entries in decreasing
    order (as in the Mathematica notebook post-processing).

    Returns: a Python list (descending-sorted entries) or None if kernel dimension ≠ 1.
    """
    K = Matrix(QQ, M).right_kernel()
    if K.dimension() != _sage_const_1 :
        return None
    v = primitive_integer_vector(K.basis()[_sage_const_0 ])
    return sorted(list(v), reverse=True)

def to_paper_convention(desc_sorted_list):
    """
    The paper’s printed representative uses the opposite sign relative to our
    canonicalization step. To match that, multiply by -1 and sort in decreasing order.
    """
    flipped = [-x for x in desc_sorted_list]
    return sorted(flipped, reverse=True)

# ===== Main routine =====
def main(print_debug=False):
    """
    Build 6×7 matrices with the top row equal to (1,...,1) to encode the barycenter
    constraint, and the remaining five rows equal to a 5-subset of the exponent set.
    For each matrix whose rank is 6, extract the right-kernel direction and record
    its (signless) fingerprint; finally convert to the paper’s printing convention.
    """
    all_ones = vector(ZZ, [_sage_const_1 ]*dim)
    result_set = set()

    for subset in combinations(indexset, dim-_sage_const_2 ):  # choose 5 of the 6 exponent vectors
        rows = [all_ones] + list(subset)         # 1 + 5 = 6 rows in a 6×7 matrix
        M = Matrix(ZZ, rows)
        rk = M.rank()
        if print_debug:
            print("rank(M) =", rk, " kernel_dim =", Matrix(QQ, M).right_kernel().dimension())
        if rk == dim - _sage_const_1 :                         # expect rank 6 ⇒ 1-dimensional kernel
            fp = fingerprint_from_nullspace(M)    # descending (signless) list
            if fp is not None:
                # Normalize to the paper’s convention right before storing/printing
                paper_vec = to_paper_convention(fp)
                result_set.add(tuple(paper_vec))

    # Deduplicate and print in a stable order
    formatted = [list(v) for v in sorted(result_set, reverse=True)]
    print(formatted)

if __name__ == "__main__":
    # Set print_debug=True to see ranks and kernel dimensions for each subset
    main(print_debug=False)

