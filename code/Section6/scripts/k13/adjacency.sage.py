

# This file was *autogenerated* from the file adjacency.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6)# adjacency.sage
# Compute the 1-PS weight vector r from the given exponent set (Case k=13).
# The script finds r such that:
#   - r · i is constant for all i in the index set,
#   - sum(r_i) = 0,
# and outputs the fingerprint (−r sorted in descending order).

from sage.all import *

# Exponent set for Case k=13 (I(r_13)_{=0})
indexset = [
    (_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_3 , _sage_const_0 , _sage_const_0 , _sage_const_0 ),
    (_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 ),
    (_sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 ),
    (_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 ),
    (_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 ),
    (_sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 ),
    (_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 ),
    (_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 ),
    (_sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ),
    (_sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ),
    (_sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ),
    (_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 ),
]

def primitive_integer_vector(v):
    """Convert a rational vector to a primitive integer vector."""
    L = lcm([c.denominator() for c in v])
    w = [(c * L).numerator() for c in v]
    g = gcd([abs(x) for x in w if x != _sage_const_0 ]) or _sage_const_1 
    return vector(ZZ, [x // g for x in w])

# Construct matrix with difference vectors and the sum=0 constraint
E = [vector(QQ, e) for e in indexset]
i0 = E[_sage_const_0 ]
rows = [(E[j] - i0) for j in range(_sage_const_1 , len(E))]
rows.append(vector(QQ, [_sage_const_1 ] * _sage_const_7 ))
M = Matrix(QQ, rows)

# Compute the right kernel (should be one-dimensional)
ker = M.right_kernel()
if ker.dimension() != _sage_const_1 :
    raise ValueError("Right kernel dimension is not 1")
r = primitive_integer_vector(ker.basis()[_sage_const_0 ])

# Normalize orientation: enforce non-increasing order
if not all(r[i] >= r[i + _sage_const_1 ] for i in range(_sage_const_6 )):
    r = -r

# Output fingerprint (−r sorted in descending order)
fingerprint = sorted([-int(ri) for ri in r], reverse=True)
print([fingerprint])

