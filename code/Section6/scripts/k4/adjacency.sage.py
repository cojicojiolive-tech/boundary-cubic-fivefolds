# -*- coding: utf-8 -*-


# This file was *autogenerated* from the file adjacency.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7 = Integer(7); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)# adjacency.sage
#
# Title:
#   Adjacency detector for k = 4 (cubic fivefolds, Section 6)
#
# Purpose:
#   Given the degree-3 exponent vectors used for Case k = 4, take every 5-subset
#   together with the barycenter row η = (1,...,1) to form a 6×7 matrix. The
#   1-dimensional right kernel gives, up to scaling/sign, the normal direction
#   r ∈ Z^7 to the corresponding face; this coincides with a 1‑PS weight.
#   We output a positionless “fingerprint” of r using the paper/Mathematica
#   convention:
#      (i) clear denominators → primitive integer vector,
#     (ii) fix sign so the first nonzero entry is positive,
#    (iii) for printing only: multiply by −1 and sort entries in decreasing order.
#
# Context:
#   This reproduces the micro-step behind the adjacency / wall-crossing
#   computation for Case k = 4 in Section 6; the eight monomials below are
#   exactly those appearing in the k = 4 construction of Section 4.4 (eq. (4)).
#
# How to run:
#   sage adjacency.sage
#
# Output:
#   Deduplicated fingerprints in the paper/Mathematica convention.
#   For this index set the expected output is:
#       [[3, 2, 1, 0, -1, -2, -3]]
#
# Requirements:
#   SageMath (tested on 9.x/10.x)

from itertools import combinations

# ===== Ambient parameters =====
dim = _sage_const_7    # variables x0,...,x6
deg = _sage_const_3    # total degree (cubic); kept for clarity

# ===== Exponent set for k = 4 (eight monomials) =====
#   x3^3, x2*x3*x4, x1*x4^2, x2^2*x5, x1*x3*x5, x0*x4*x5, x1*x2*x6, x0*x3*x6
#   Each vector lists exponents of (x0, x1, x2, x3, x4, x5, x6).
indexset = [
    vector(ZZ, [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_3 , _sage_const_0 , _sage_const_0 , _sage_const_0 ]),  # x3^3
    vector(ZZ, [_sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 ]),  # x2 * x3 * x4
    vector(ZZ, [_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 ]),  # x1 * x4^2
    vector(ZZ, [_sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 ]),  # x2^2 * x5
    vector(ZZ, [_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 ]),  # x1 * x3 * x5
    vector(ZZ, [_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 ]),  # x0 * x4 * x5
    vector(ZZ, [_sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ]),  # x1 * x2 * x6
    vector(ZZ, [_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 ]),  # x0 * x3 * x6
]

# ===== Utilities =====
def primitive_integer_vector(v):
    """
    Convert a rational vector v ∈ QQ^n to a primitive integer vector in ZZ^n:
      (1) clear denominators (multiply by lcm of denominators and take numerators);
      (2) divide by gcd of nonzero entries;
      (3) fix sign so the first nonzero entry is positive.
    Returns: vector(ZZ, n)
    """
    vv = vector(QQ, v)
    if vv.is_zero():
        return vector(ZZ, [_sage_const_0 ]*vv.length())

    den_lcm = lcm([x.denominator() for x in vv])
    w = vector(ZZ, [(x * den_lcm).numerator() for x in vv])

    g = gcd([abs(a) for a in w if a != _sage_const_0 ])
    if g != _sage_const_0 :
        w = vector(ZZ, [a // g for a in w])

    for a in w:
        if a != _sage_const_0 :
            if a < _sage_const_0 :
                w = -w
            break
    return w

def fingerprint_from_nullspace(M):
    """
    Take a 6×7 matrix M (top row = all-ones), compute a basis of the 1-dim
    right kernel over QQ, normalize to a primitive integer vector, and return a
    positionless “fingerprint”: the entries sorted in decreasing order.
    """
    K = Matrix(QQ, M).right_kernel()
    if K.dimension() != _sage_const_1 :
        return None
    v = primitive_integer_vector(K.basis()[_sage_const_0 ])
    return sorted(list(v), reverse=True)

def to_paper_convention(desc_sorted_list):
    """
    Apply the paper/Mathematica printing convention:
      multiply by −1 and sort in decreasing order.
    """
    flipped = [-x for x in desc_sorted_list]
    return sorted(flipped, reverse=True)

# ===== Main routine =====
def main(print_debug=False):
    """
    Build 6×7 matrices with top row (1,...,1) and the remaining five rows a
    5-subset of the eight exponent vectors. For each rank-6 matrix, extract the
    1‑PS direction from the right kernel and print it in the paper’s convention.
    """
    all_ones = vector(ZZ, [_sage_const_1 ]*dim)
    result_set = set()

    for subset in combinations(indexset, dim - _sage_const_2 ):  # choose 5 of the 8
        rows = [all_ones] + list(subset)
        M = Matrix(ZZ, rows)
        if print_debug:
            rk = M.rank()
            kd = Matrix(QQ, M).right_kernel().dimension()
            print("rank(M) =", rk, "kernel_dim =", kd)
        if M.rank() == dim - _sage_const_1 :  # rank 6 ⇒ 1-dimensional kernel
            fp = fingerprint_from_nullspace(M)  # descending, signless
            if fp is not None:
                paper_vec = to_paper_convention(fp)
                result_set.add(tuple(paper_vec))

    # Deduplicate and print in a stable order
    formatted = [list(v) for v in sorted(result_set, reverse=True)]
    print(formatted)

if __name__ == "__main__":
    # Set print_debug=True to see ranks and kernel dimensions for each subset
    main(print_debug=False)

