# -*- coding: utf-8 -*-


# This file was *autogenerated* from the file adjacency.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2)#!/usr/bin/env sage
# ------------------------------------------------------------
# Adjacency finder for cubic fivefolds (k = 4 case)
#
# What this script does:
#   Given an index set of exponent vectors (monomials where the
#   equality r·i = 0 is expected on a face passing through the
#   barycenter), it solves for the 1-PS weight vector r ∈ Z^7(0).
#   We compute a rational kernel vector, clear denominators to get
#   a primitive integer vector, then (to match the Mathematica
#   convention used in the paper) multiply by -1 and sort in
#   nonincreasing order before printing.
#
# References:
#   Numerical criterion and face/normal-vector setup follow
#   Lemma 2.1 and Algorithm 2.2 (and surrounding discussion)
#   in the paper on cubic fivefolds.  The list of weight vectors
#   is summarized in Proposition 2.3.  See the uploaded PDF.
# ------------------------------------------------------------

from sage.all import QQ, ZZ, matrix, vector, lcm, gcd

# ---------- Utilities ----------

def primitive_integer_vector(vq):
    """
    Convert a rational vector to a primitive integer vector.
    1) clear denominators by multiplying by LCM of denominators
    2) divide by the gcd of the integer entries
    """
    vq = vector(QQ, vq)
    den = lcm([x.denominator() for x in vq]) if len(vq) else ZZ(_sage_const_1 )
    wi = [ZZ(x * den) for x in vq]  # exact, since x ∈ QQ
    # gcd over all entries (allowing zeros)
    g = ZZ(_sage_const_0 )
    for z in wi:
        g = gcd(g, z)
    g = abs(g)
    if g == _sage_const_0 :
        g = ZZ(_sage_const_1 )
    wi = [z // g for z in wi]
    return vector(ZZ, wi)

def normalize_to_mathematica(w):
    """
    Match the convention used in the Mathematica notebooks:
    - multiply by -1
    - sort entries in nonincreasing order
    """
    w = -vector(ZZ, w)
    return vector(ZZ, sorted(list(w), reverse=True))

def build_constraint_matrix(indexset):
    """
    Build the linear constraint matrix M so that M * r = 0 encodes:
      - r · i_j = 0  for each exponent vector i_j in indexset
      - sum(r_k) = 0  (i.e. r · (1,...,1) = 0, the SL-condition)
    We work over QQ to keep exact arithmetic.
    """
    rows = [vector(QQ, idx) for idx in indexset]
    rows.append(vector(QQ, [_sage_const_1 ]*_sage_const_7 ))  # Σ r_k = 0  (equivalent to r·η = 0)
    return matrix(QQ, rows)

def fingerprint_from_nullspace(M):
    """
    Compute a primitive integer kernel vector and return it
    normalized for publication (sign-flipped + descending).
    """
    K = M.right_kernel()
    basis = K.basis()
    if len(basis) == _sage_const_0 :
        raise ValueError("Right kernel is trivial; no nonzero solution for r.")
    if len(basis) > _sage_const_1 :
        # Typically we expect a 1-dimensional kernel. If larger, we still
        # pick the first basis vector but warn the user.
        print("[warning] kernel has dimension %d; using the first basis vector." % len(basis))
    v_prim = primitive_integer_vector(basis[_sage_const_0 ])
    return normalize_to_mathematica(v_prim)

# ---------- Input: k = 4 case ----------

# The index set provided by the user (each row sums to degree 3)
indexset = [
    [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_3 , _sage_const_0 , _sage_const_0 , _sage_const_0 ],
    [_sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_0 ],
    [_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 ],
    [_sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 ],
    [_sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 ],
    [_sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ],
]

# ---------- Main ----------

if __name__ == "__main__":
    M = build_constraint_matrix(indexset)
    r = fingerprint_from_nullspace(M)
    # Print as a one-row "Mathematica-style" list-of-list to match previous runs
    print([r.list()])

